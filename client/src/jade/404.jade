extends templates/master

block title
	| 404: Page Not Found - Darryl Snow &ndash; Web designer, developer, and project manager

block styles

	style.
		body {
			background: #282a3a;
			margin: 0px;
			padding: 0px;
		}
		.banner {
			left: 50%;
			position: absolute;
			text-align: center;
			top: 50%;
			transform: translateX(-50%) translateY(-50%)
		}
		.banner h1 {
			pointer-events: none;
		}
		.button:hover {
			background: rgba(255,255,255,0.1);
		}

block content

	canvas.js-starfield
	.banner
		h1 Lost?
			span.subheading The page you were looking for isn't here so...
		a.button(href="/", title="Go to the homepage") Come back to us
			svg.icon(viewBox="0 0 32 32")
					use(xlink:href="#icon-arrow-left")

block scripts

	script.
		/*****************************************************************************
		The MIT License (MIT)

		Copyright (c) 2014 Andi Smithers

		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:

		The above copyright notice and this permission notice shall be included in
		all copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
		THE SOFTWARE.
		*****************************************************************************/

		// conceptualized and written by andi smithers
		// globals
		var canvas, context, alpha;
		var cX, cY, tX, tY, mouseX, mouseY, density;
		var stars = [];
		var cameraDepth=0;
		var enterWarp, warpStartDepth, warpTime, velocity;

		// define to 0 to brute force move all stars
		const cameraTrick = 1;

		// options
		const starCount = 1024;
		var initVelocity = -1.0;
		var termVelocity = -10.0;
		const topleft = 0;
		const trackMouse = 1;
		const focalPoint = 256;
		const sparcity = 1.0;
		const tailLength = 20;

		// depth modulo fucntion. custom
		function modulo(a){
			// depth range is 1024
			const b = 1024;
				return a-b * Math.floor(a/b);
		}

		// handles negative numbers correctly
		function modulo2(a, b){
			return a-b * Math.floor(a/b);
		}

		function Star(index){
			// randomize a field -1024 to 1024 and positive z
			this.x = (Math.random() *2048-1024)*sparcity;
			this.y = (Math.random() *2048-1024)*sparcity;
			this.z = ((starCount-1)-index)/density;
		
			if (topleft==1) 
			{
				this.x = this.x + 1024;
				this.y = this.y + 1024;
			}
		}

		Star.prototype.move = function(){
			// dont really have to move all stars
			this.z = modulo(this.z + velocity)
		}

		Star.prototype.draw = function() {
			// compute depth perspective effect, cameraDepth is used when cameraTrick = 1
			var depth = focalPoint / (modulo(this.z + cameraDepth) +1);
			var x = this.x * depth + cX;
			var y = this.y * depth + cY;
			var sz = 5 * depth;
			
			// fill a rect
			context.beginPath();
			context.arc(x, y, sz, 0, 2 * Math.PI, false);
			//- context.rect(x, y, sz,sz);
			context.fillStyle = 'white';
			context.fill();
			// use border edge for twinkle effect 
			context.lineWidth = 0;
			context.strokeStyle = '#282a3a';
			context.stroke();
		};

		Star.prototype.warpline = function() {
			var depth = modulo(this.z + cameraDepth)+1;
			var depthStart = modulo(this.z + warpStartDepth)+1
			if (depth>depthStart && termVelocity<0) depth = 1;
			if (depth<depthStart && termVelocity>0) depthStart = 1;
			
			var invDepth = focalPoint / depth;
			var invDepthStart = focalPoint / depthStart;
			
			var x = this.x * invDepth + cX;
			var y = this.y * invDepth + cY;
			var sz = 5 * invDepth ;
			
			var wx = this.x * invDepthStart + cX;
			var wy = this.y * invDepthStart + cY;
			var wsz = 5 * invDepthStart;

			// computed quadrant dictates what 2 edges we see in rendering the trail
			var top = this.y<0? sz : 0;
			var left = this.x<0? sz : 0;
			var alpha = (sz/5.0+0.1) * 0.7;
			// fill a ray
			context.beginPath();
			context.moveTo(wx, wy);
			context.lineTo(x+sz, y+top);
			context.lineTo(x, y+top);
			context.moveTo(wx, wy);
			context.lineTo(x+left, y+sz);
			context.lineTo(x+left, y);
			context.closePath();
			context.fillStyle = termVelocity<0?'rgba(64,128,192,'+alpha+')':'rgba(192,64,32,'+ alpha+')';
			context.fill();
			// use border edge for twinkle effect 
			// context.lineWidth = 0;
			// context.strokeStyle = 'black';
			// context.stroke();
		};

		function init(){
			// setup canvas and context
			canvas = document.getElementsByClassName('js-starfield')[0];
			context = canvas.getContext('2d');
			// set canvas to be window dimensions
			resize();
			canvas.addEventListener('mousemove', mousemove);
			canvas.addEventListener('click', mouseclick);
			window.addEventListener('resize', resize);

			// compute center of screen (its really centre but for americans I change it)
			tX = cX = canvas.width/2;
			tY = cY = canvas.height/4;

			if (topleft==1) 
			{
				cX=0;
				cY=0;
			}

			density = starCount/1024;
			// allocate and init stars
			for (i=0; i<starCount; i++)
			{
				stars[i] = new Star(i);
			}

			alpha = 6.0;
			enterWarp = false;
			velocity = initVelocity;
		}

		function animate(){
			// movement update
			move();
			// render update
			render();
			// trigger next frame
			requestAnimationFrame(animate);
		}

		function move(){
			if (enterWarp)
			{
				velocity*=1.02;
				if (velocity<termVelocity && termVelocity<0) velocity=termVelocity;
				if (velocity>termVelocity && termVelocity>0) velocity=termVelocity;
				warpTime=warpTime+1;
				if (warpTime>140) enterWarp = false;
				if (warpTime>tailLength) warpStartDepth=modulo(warpStartDepth+velocity);
				// catchup time
				if (warpTime>130)
				{
					warpStartDepth = modulo(warpStartDepth + (cameraDepth-warpStartDepth) * 0.3);
				}
			}
			else
			{
				// slow down
				var dv = velocity - initVelocity;
				velocity-= dv * 0.01;
			}
			// brute force move.. will replace with camera trick
			if (cameraTrick==0)
			{
				for (i = 0; i < stars.length; i++) 
				{
					stars[i].move();
				};
			}
			else
			{
				// camera movement trick
				cameraDepth = modulo(cameraDepth+velocity);
			}

			var dx = tX - cX;
			var dy = tY - cY;
			var dist = Math.sqrt(dx*dx + dy*dy);
		
			if (dist!=0)
			{
				dx/=dist;
				dy/=dist;
			}
			dist = Math.min(dist, 512.0);
		
			cX = cX + (dist*dx*0.06125);
			cY = cY + (dist*dy*0.06125);
		}

		function render(){
			// brute force clear
			context.clearRect(0, 0, canvas.width, canvas.height);

			// draw all stars
			for (i = 0; i < stars.length; i++) 
			{
				var index = cameraTrick==1 ? modulo2((i + 1 + Math.floor(cameraDepth)*density) , stars.length) : i;
				// depending on direction of travel is order of drawing trails
				if (enterWarp && termVelocity<=0) stars[index].warpline();
				stars[index].draw();
				if (enterWarp && termVelocity>0) stars[index].warpline();
			};
		}

		function mousemove(event) {
			var rect = canvas.getBoundingClientRect();

			mouseX = event.clientX - rect.left,
			mouseY = event.clientY - rect.top
			// just for fun lets just click on moving
			if (trackMouse)
			{
				tX = mouseX;
				tY = mouseY;
				if (termVelocity>0)
				{
					tX = canvas.width - tX;
					tY = canvas.height - tY;
				}
			}
		}

		function mouseclick(){
			tX = mouseX;
			tY = mouseY;
			if (termVelocity>0)
			{
				tX = canvas.width - tX;
				tY = canvas.height - tY;
			}
			// swap
			if (hitButton(canvas.width/2-100, 10, 200, 32))
			{
				swapView();
				return;
			}

			if (!enterWarp)
			{
				enterWarp = true;
				warpStartDepth = cameraDepth;
				warpTime = 0;
			}
		}

		function resize(){
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		}

		function swapView(){
			// inverse the velocities
			initVelocity*=-1;
			termVelocity*=-1;
			velocity*=-1;
			// switch warplines
			if (enterWarp)
			{
				var tmp = cameraDepth;
				cameraDepth = warpStartDepth;
				warpStartDepth = tmp;
			}
			// change view point of travel
			if (termVelocity>0)
			{
				cX = canvas.width - cX;
				cY = canvas.height - cY;
				tX = canvas.width - tX;
				tY = canvas.height - tY;
				}
			else
			{
				cX = canvas.width - cX;
				cY = canvas.height - cY;
				tX = mouseX;
				tY = mouseY;
			}
		}

		function hitButton(x, y, w, h){
			return (mouseX>x && mouseX<x+w && mouseY>y && mouseY<y+h) ? true : false;
		}

		function createButton(x, y, w, h, name){
		 	// fill a rect
		 	context.beginPath();
		 	context.rect(x, y, w,h);
		 	context.fillStyle = 'rgba(0, 0, 0, 0.5)';
		 	context.fill();
		
		 	context.lineWidth = 2;
		 	context.strokeStyle = 'rgba(120, 120, 120, 0.5)';
		 	context.stroke();
		 	
		 	context.moveTo(x,y);
		 	context.font = '20pt Calibri';
		 	context.fillStyle = 'rgba(255,255,255, 1)';
		 	context.textAlign = "center";
		 	context.fillText(name, x+w/2, y+h-9);
		}

		// entry point
		init();
		animate();